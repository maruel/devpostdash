<!DOCTYPE html>
{{/*
Copyright 2025 Marc-Antoine Ruel. All rights reserved.
Use of this source code is governed under the Apache License, Version 2.0
that can be found in the LICENSE file.
*/}}
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>{{.Title}}</title>
	<style>
		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			margin: 0;
			padding: 0;
			color: #ecf0f1;
			line-height: 1.6;
			overflow: hidden;
			/* Hide body scrollbars */
		}

		h1 {
			color: #ecf0f1;
			text-align: center;
			margin-bottom: 20px;
			font-size: 2.5em;
			font-weight: 600;
		}

		.card-carousel {
			position: relative;
			width: 100vw;
			height: 80vh;
			perspective: 1000px;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		.project-card {
			position: absolute;
			width: 400px;
			height: 70vh;
			max-height: 500px;
			background: linear-gradient(120deg, #f8fafc 0%, #e0e7ff 100%);
			color: #ecf0f1;
			border-radius: 12px;
			box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
			padding: 25px;
			box-sizing: border-box;
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			transition: transform 0.8s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.8s;
			transform-style: preserve-3d;
			opacity: 0;
			transform: translateZ(-200px) rotateY(0deg);
		}

		.project-card.active {
			opacity: 1;
			transform: translateZ(0) rotateY(0deg);
			z-index: 10;
		}

		.project-card.next {
			opacity: 0.5;
			transform: translateX(50%) translateZ(-100px) rotateY(-45deg);
			z-index: 5;
		}

		.project-card.prev {
			opacity: 0.5;
			transform: translateX(-50%) translateZ(-100px) rotateY(45deg);
			z-index: 5;
		}

		.project-card h2 {
			margin-top: 0;
			margin-bottom: 10px;
			font-size: 1.6em;
			color: #ecf0f1;
		}

		.project-card h2 a {
			text-decoration: none;
			color: #007bff;
			transition: color 0.2s ease;
		}

		.project-card h2 a:hover {
			color: #5dade2;
		}

		.project-card .tagline {
			font-style: italic;
			color: #7f8c8d;
			margin-bottom: 15px;
			font-size: 0.95em;
		}

		.project-card .team-members {
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			margin-top: 15px;
			margin-bottom: 15px;
		}

		.project-card .team-member {
			display: flex;
			align-items: center;
			margin-right: 15px;
			margin-bottom: 10px;
			background-color: rgba(255, 255, 255, 0.1);
			padding: 5px 10px;
			border-radius: 20px;
			transition: background-color 0.3s;
		}

		.project-card .team-member:hover {
			background-color: rgba(255, 255, 255, 0.2);
		}

		.project-card .team-member img {
			border-radius: 50%;
			width: 35px;
			height: 35px;
			margin-right: 10px;
			border: 2px solid #ecf0f1;
		}

		.project-card .team-member span {
			color: #34495e;
			font-size: 0.9em;
			font-weight: 500;
		}

		.project-card .likes {
			font-weight: bold;
			color: #e74c3c;
			font-size: 1.1em;
			display: flex;
			align-items: center;
			justify-content: flex-end;
			margin-top: auto;
		}

		.project-card .likes::before {
			content: '‚ù§Ô∏è';
			margin-right: 5px;
		}

		.github-link {
			text-align: center;
			margin-top: 20px;
			font-size: 1.1em;
		}

		.github-link a {
			color: #3498db;
			text-decoration: none;
			font-weight: 500;
			transition: color 0.2s ease;
		}

		.github-link a:hover {
			color: #5dade2;
			text-decoration: underline;
		}

		@media screen and (orientation: portrait) {
			.project-card {
				width: 80vw;
			}

			.project-card.next {
				transform: translateX(30%) translateZ(-100px) rotateY(-45deg);
			}

			.project-card.prev {
				transform: translateX(-30%) translateZ(-100px) rotateY(45deg);
			}
		}
	</style>
</head>

<body>
	<div class="card-carousel">
		{{range .Projects}}
		<div class="project-card">
			<h2>
				<a href="{{.URL}}">{{.Title}}</a>{{if .Winner}} üèÜ{{end}}
			</h2>
			<p class="tagline">{{.Tagline}}</p>
			<div class="team-members">
				{{range .Team}}
				<a href="{{.URL}}">
					<div class="team-member">
						<img src="{{.AvatarURL}}" alt="{{.Name}}" title="{{.Name}}" />
						<span>{{.Name}}</span>
					</div>
				</a>
				{{end}}
			</div>
			<div class="likes">{{.Likes}}</div>
		</div>
		{{end}}
	</div>

	<script type="importmap">
	{
		"imports": {
				"three": "https://threejs.org/build/three.module.min.js",
				"three/addons/": "https://threejs.org/examples/jsm/"
			}
		}
	</script>
	<script type="module">
		import * as THREE from 'three';

		const vertexShader = `
			precision highp float;
			uniform float time;
			varying float vNoise;

			// Perlin 3D Noise.
			vec4 permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
			vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
			vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

			float cnoise(vec3 P) {
				vec3 Pi0 = floor(P); // Integer part for indexing
				vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
				Pi0 = mod(Pi0, 289.0); Pi1 = mod(Pi1, 289.0); // Wrap to 0-288
				vec3 Pf0 = fract(P); // Fractional part for interpolation
				vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
				vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
				vec4 iy = vec4(Pi0.yy, Pi1.yy);
				vec4 iz0 = Pi0.zzzz;
				vec4 iz1 = Pi1.zzzz;

				vec4 ixy = permute(permute(ix) + iy);
				vec4 ixy0 = permute(ixy + iz0);
				vec4 ixy1 = permute(ixy + iz1);

				vec4 gx0 = ixy0 / 7.0; // Value of gx0 from 0-1
				vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
				gx0 = fract(gx0); // Keep only fractional part
				vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
				vec4 sz0 = step(gz0, vec4(0.0));
				gx0 -= sz0 * (step(0.0, gx0) - 0.5);
				gy0 -= sz0 * (step(0.0, gy0) - 0.5);

				vec4 gx1 = ixy1 / 7.0;
				vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
				gx1 = fract(gx1); // Keep only fractional part
				vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
				vec4 sz1 = step(gz1, vec4(0.0));
				gx1 -= sz1 * (step(0.0, gx1) - 0.5);
				gy1 -= sz1 * (step(0.0, gy1) - 0.5);

				vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
				vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
				vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
				vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
				vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
				vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
				vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
				vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

				vec4 norm0 = taylorInvSqrt(vec4(dot(g000,g000), dot(g010,g010), dot(g100,g100), dot(g110,g110)));
				vec4 norm1 = taylorInvSqrt(vec4(dot(g001,g001), dot(g011,g011), dot(g101,g101), dot(g111,g111)));
				g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w;
				g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w;

				float n000 = dot(g000, Pf0);
				float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
				float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
				float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
				float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
				float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
				float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
				float n111 = dot(g111, Pf1);

				vec3 fade_xyz = fade(Pf0);
				vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
				vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
				float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
				return 2.2 * n_xyz;
			}

			float turbulence( vec3 p ) {
				float w = 1.0;
				float t = 0.0;
				for (float i=0.; i<5.; i++) {
					t += abs(cnoise(p / w)) * w;
					w /= 2.0;
				}
				return t;
			}

			void main() {
				vNoise = 0.5 * turbulence( 0.1 * (position + time * 10.0) );
				float displacement = vNoise * 50.0;
				vec3 newPosition = position + normal * displacement;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
			}
		`;

		const fragmentShader = `
			precision highp float;
			varying float vNoise;
			uniform float time;

			void main() {
				vec3 color = vec3(0.0);
				float intensity = abs(vNoise);

				// Red to orange to yellow
				color = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 0.6, 0.0), intensity * 2.0); // Red to Orange
				color = mix(color, vec3(1.0, 1.0, 0.0), (intensity - 0.5) * 2.0); // Orange to Yellow

				gl_FragColor = vec4(color, 1.0);
			}
		`;

		let camera, scene, renderer, mesh;
		let uniforms;
		let previousTime = 0;

		function background() {
			// 3D background
			renderer = new THREE.WebGLRenderer({antialias: true});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			renderer.domElement.style.position = 'absolute';
			renderer.domElement.style.top = 0;
			renderer.domElement.style.left = 0;
			renderer.domElement.style.zIndex = -1; // Ensure it's in the background

			// Scene
			scene = new THREE.Scene();

			// Starfield
			const starsGeometry = new THREE.BufferGeometry();
			const starsMaterial = new THREE.PointsMaterial({color: 0xffffff, size: 1, sizeAttenuation: true});

			const starVertices = [];
			for (let i = 0; i < 10000; i++) {
				const x = (Math.random() - 0.5) * 2000;
				const y = (Math.random() - 0.5) * 2000;
				const z = (Math.random() - 0.5) * 2000;
				starVertices.push(x, y, z);
			}
			starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

			const stars = new THREE.Points(starsGeometry, starsMaterial);
			scene.add(stars);

			// Camera
			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.z = 400;

			// Object
			const geometry = new THREE.SphereGeometry(200, 128, 64);
			uniforms = {
				time: {value: 1.0},
			};
			const material = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
			});
			mesh = new THREE.Mesh(geometry, material);
			scene.add(mesh);

			window.addEventListener('resize', onWindowResize);
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate(currentTime) {
			requestAnimationFrame(animate);
			const deltaTime = (currentTime - previousTime) * 0.001; // Convert to seconds
			previousTime = currentTime;
			uniforms.time.value += deltaTime * 0.05; // Adjust uniform update for deltaTime
			camera.rotation.y += deltaTime * 0.05; // Adjust rotation speed for deltaTime
			mesh.rotation.y += deltaTime * 0.1; // Adjust rotation speed for deltaTime
			renderer.render(scene, camera);
		}

		background();
		previousTime = document.timeline.currentTime;
		animate(previousTime);
	</script>

	<script>
		// UI
		document.addEventListener('DOMContentLoaded', () => {
			const cards = document.querySelectorAll('.project-card');
			let currentIndex = 0;
			let autoRotateInterval;

			function updateCards() {
				cards.forEach((card, index) => {
					card.classList.remove('active', 'prev', 'next');
					if (index === currentIndex) {
						card.classList.add('active');
					} else if (index === (currentIndex + 1) % cards.length) {
						card.classList.add('next');
					} else if (index === (currentIndex - 1 + cards.length) % cards.length) {
						card.classList.add('prev');
					}
				});
			}

			function resetAutoRotate() {
				clearInterval(autoRotateInterval);
				autoRotateInterval = setInterval(showNext, 10000); // 10 seconds
			}

			function showNext() {
				currentIndex = (currentIndex + 1) % cards.length;
				updateCards();
				resetAutoRotate();
			}

			function showPrev() {
				currentIndex = (currentIndex - 1 + cards.length) % cards.length;
				updateCards();
				resetAutoRotate();
			}

			function requestFullscreen() {
				const elem = document.documentElement;
				if (elem.requestFullscreen) {
					elem.requestFullscreen();
				} else if (elem.webkitRequestFullscreen) { // Safari
					elem.webkitRequestFullscreen();
				} else if (elem.msRequestFullscreen) { // IE11
					elem.msRequestFullscreen();
				}
			}

			// Initial setup
			if (cards.length > 0) {
				updateCards();
				resetAutoRotate();
				// Added this to go fullscreen.
				document.body.addEventListener('click', requestFullscreen, {once: true});
			}

			// Scroll handling
			let scrollTimeout;
			window.addEventListener('wheel', (event) => {
				if (window.innerWidth - event.clientX < 200) { // Detect scroll on the right side
					event.preventDefault();
					clearTimeout(scrollTimeout);
					scrollTimeout = setTimeout(() => {
						if (event.deltaY > 0) {
							showNext();
						} else {
							showPrev();
						}
					}, 50); // Debounce scroll events
				}
			}, {passive: false});

			document.addEventListener('keydown', (event) => {
				if (event.key === 'ArrowRight') {
					showNext();
				} else if (event.key === 'ArrowLeft') {
					showPrev();
				}
			});

			const carousel = document.querySelector('.card-carousel');
			let touchStartX = 0;
			let touchEndX = 0;

			carousel.addEventListener('touchstart', (event) => {
				touchStartX = event.changedTouches[0].screenX;
			}, {passive: true});

			carousel.addEventListener('touchend', (event) => {
				touchEndX = event.changedTouches[0].screenX;
				handleSwipe();
			}, {passive: true});

			function handleSwipe() {
				const swipeThreshold = 50; // Minimum distance for a swipe
				if (touchStartX - touchEndX > swipeThreshold) {
					showNext();
				} else if (touchEndX - touchStartX > swipeThreshold) {
					showPrev();
				}
			}
		});
	</script>
</body>

</html>
